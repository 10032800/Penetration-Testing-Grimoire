# Limited Shell Commands and Scripts
Some shell that you may encounter, may be in chrooted environments, docker images, containers, etc and not have the same resources that we are used to using with our own systems. For instance, if we are missing the `cat` command, how would we read files? 
## System Information Gathering
We can try these commands when we are in extremely limimted shells.
### Network Information
To gather system network information withou the common `ifconfig` command, we can use the following commands,
* `cat /proc/net/dev`
* `lspci`
* `netstat -i`
* `ip link show`
* `ip addr show`
## Bash Scripting
These Bash one-liner scripts will help when we encounter extremely limited shells. These work because certain commands are not external compiled programs, but built directly into Bash and many other shells. Some examples are, `while`, `for`, `if`, and other basic logic operators allow us to construct these scripts while in a pinch.
### Cat
We can use the following Bash script to read the contents of a file when we do not have access to the basic `cat` command.
```
user@target-system:$ while read line; do echo $line; done < filename.txt
```
For example, say we do not have acces to `cat`, how would we go about executing the following command listed in the previous section to get the network device info?
```
cat /proc/net/dev
```
We can use Bash redirect and a `while read` loop construct as so,
```
user@target-system:$ while read line; do echo $line; done < /proc/net/dev
```
### Ls
Listing files without access to the `ls` command is easy,
```
user@target-system:$ for file in *; do echo $file; done
```
### Pivoting and NMap
#### Host Discovery
Without the `nmap`, `ettercap` or `netdiscover` programs, how could we determine what hosts we could pivot to if we find multiple interfaces on a compromised machine? Each interface could lead to multiple systems in multiple separate networks- some of which are intended to be internal or private. 

Try my [host-discov.sh](https://github.com/weaknetlabs/Penetration-Testing-Grimoire/blob/master/Tools/host-discov.sh) script. It requires 2 arguments, the first three octets of the network, then the range of the final octets, like so,
```
user@target-system:$ ./host-discov.sh 192.168.1 5-78
```
This will use `ping` to determine if the hosts in the range, `192.168.1.5-78` are alive.
#### Port Scanning
Again, without `nmap` whgat is a good way to port scan a potential internal target from a compromised system? We will use `/dev/tcp` again. Also, I made the applications similar, so taht they take the same exact style of arguments; the target and a range. This time, the range is ports, not the final octet of an IP address.

Try my [portscan.sh](https://github.com/weaknetlabs/Penetration-Testing-Grimoire/blob/master/Tools/portscan.sh) script.
### cURL
What do we do without `curl` when we find an internal web service running? Well, we can use the `/dev/tcp` system for that too.
 1. Start with the `exec` command. This allows us to open files in the current shell and asign to them a file descriptor, in our case will just be the number `3`.
 2. Send into the `/dev/tcp` device that we just opened on the remote server an HTT GET request header for 1.1
 3. Cat the file descriptor to view the output. Or use the method above if `cat` is missing to read files with the `while` logical constructor.
```
user@target-system:/tmp# exec 3<>/dev/tcp/(INTERNAL IP ADDRESS)/80
exec 3<>/dev/tcp/172.19.0.3/80
user@target-system:/tmp# echo -e "GET / HTTP/1.1">&3
echo -e "GET / HTTP/1.1">&3
user@target-system:/tmp# cat <&3
cat <&3
HTTP/1.1 400 Bad Request
Date: Sun, 27 Jan 2019 06:20:03 GMT
Server: Apache/2.4.10 (Debian)
Content-Length: 302
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.4.10 (Debian) Server at 172.19.0.3 Port 80</address>
</body></html>
user@target-system:/tmp# 
```
